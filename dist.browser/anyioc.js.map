{"version":3,"sources":["webpack://anyioc/webpack/bootstrap","webpack://anyioc/./dist/anyioc.js","webpack://anyioc/(webpack)/buildin/global.js"],"names":[],"mappings":";;QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;;;;;;AClFA,8CAAa;AACb;AACA,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uDAAuD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4BAA4B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,MAAM;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sBAAsB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,kC;;;;;;;;;;;;AC/PA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C","file":"anyioc.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./dist/anyioc.js\");\n","\"use strict\";\r\n/* Copyright (c) 2018~2999 - Cologler <skyoflw@gmail.com> */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ioc = exports.ServiceProvider = exports.Resolvers = exports.LifeTime = exports.Symbols = void 0;\r\nexports.Symbols = {\r\n    Provider: Symbol('Provider'),\r\n    RootProvider: Symbol('RootProvider'),\r\n    Cache: Symbol('Cache'),\r\n    MissingResolver: Symbol('MissingResolver'),\r\n};\r\nvar LifeTime;\r\n(function (LifeTime) {\r\n    LifeTime[LifeTime[\"Transient\"] = 0] = \"Transient\";\r\n    LifeTime[LifeTime[\"Scoped\"] = 1] = \"Scoped\";\r\n    LifeTime[LifeTime[\"Singleton\"] = 2] = \"Singleton\";\r\n})(LifeTime = exports.LifeTime || (exports.LifeTime = {}));\r\nvar Services;\r\n(function (Services) {\r\n    class ServiceInfo {\r\n        constructor(_factory, _lifetime, _provider) {\r\n            this._factory = _factory;\r\n            this._lifetime = _lifetime;\r\n            this._provider = _provider;\r\n            this._cache_value = null;\r\n        }\r\n        get(provider) {\r\n            switch (this._lifetime) {\r\n                case LifeTime.Transient:\r\n                    return this._factory(provider);\r\n                case LifeTime.Scoped:\r\n                    const cache = provider.get(exports.Symbols.Cache);\r\n                    if (!cache.has(this)) {\r\n                        cache.set(this, this._factory(provider));\r\n                    }\r\n                    return cache.get(this);\r\n                case LifeTime.Singleton:\r\n                    if (this._cache_value === null) {\r\n                        this._cache_value = [this._factory(this._provider)];\r\n                    }\r\n                    return this._cache_value[0];\r\n            }\r\n        }\r\n    }\r\n    Services.ServiceInfo = ServiceInfo;\r\n    class ProviderServiceInfo {\r\n        get(provider) {\r\n            return provider;\r\n        }\r\n    }\r\n    Services.ProviderServiceInfo = ProviderServiceInfo;\r\n    class ValueServiceInfo {\r\n        constructor(_value) {\r\n            this._value = _value;\r\n        }\r\n        get(provider) {\r\n            return this._value;\r\n        }\r\n    }\r\n    Services.ValueServiceInfo = ValueServiceInfo;\r\n    class GroupedServiceInfo {\r\n        constructor(_keys) {\r\n            this._keys = _keys;\r\n        }\r\n        get(provider) {\r\n            return this._keys.map(key => provider.get(key));\r\n        }\r\n    }\r\n    Services.GroupedServiceInfo = GroupedServiceInfo;\r\n    class BindedServiceInfo {\r\n        constructor(_targetKey) {\r\n            this._targetKey = _targetKey;\r\n        }\r\n        get(provider) {\r\n            return provider.get(this._targetKey);\r\n        }\r\n    }\r\n    Services.BindedServiceInfo = BindedServiceInfo;\r\n})(Services || (Services = {}));\r\nvar Resolvers;\r\n(function (Resolvers) {\r\n    class EmptyServiceInfoResolver {\r\n        get(provider, key) {\r\n            return undefined;\r\n        }\r\n    }\r\n    Resolvers.EmptyServiceInfoResolver = EmptyServiceInfoResolver;\r\n})(Resolvers = exports.Resolvers || (exports.Resolvers = {}));\r\nvar Utils;\r\n(function (Utils) {\r\n    // value of ChainMap is IServiceInfo, it cannot be undefined.\r\n    class ChainMap {\r\n        constructor(parentMaps = null) {\r\n            this._maps = [new Map()];\r\n            this._maps.push(...parentMaps || []);\r\n        }\r\n        get(key) {\r\n            for (const map of this._maps) {\r\n                const list = map.get(key);\r\n                if (list !== undefined) {\r\n                    return list[list.length - 1];\r\n                }\r\n            }\r\n            return undefined;\r\n        }\r\n        getMany(key) {\r\n            const items = [];\r\n            for (const map of this._maps) {\r\n                const list = map.get(key);\r\n                if (list !== undefined) {\r\n                    items.push(...list.slice().reverse());\r\n                }\r\n            }\r\n            return items;\r\n        }\r\n        set(key, value) {\r\n            const map = this._maps[0];\r\n            let list = map.get(key);\r\n            if (list === undefined) {\r\n                list = [];\r\n                map.set(key, list);\r\n            }\r\n            list.push(value);\r\n        }\r\n        child() {\r\n            return new ChainMap(this._maps);\r\n        }\r\n    }\r\n    Utils.ChainMap = ChainMap;\r\n    class ResolveStack {\r\n        constructor() {\r\n            this._resolveStack = new Set();\r\n        }\r\n        with(key, resolver) {\r\n            if (this._resolveStack.has(key)) {\r\n                const chain = [...this._resolveStack, key].join(' => ');\r\n                throw new Error(`Recursive detected. Chain: ${chain}`);\r\n            }\r\n            this._resolveStack.add(key);\r\n            try {\r\n                return resolver();\r\n            }\r\n            finally {\r\n                this._resolveStack.delete(key);\r\n            }\r\n        }\r\n    }\r\n    Utils.ResolveStack = ResolveStack;\r\n})(Utils || (Utils = {}));\r\nclass ScopedServiceProvider {\r\n    constructor(_services) {\r\n        this._services = _services;\r\n        this._resolveStack = new Utils.ResolveStack();\r\n        this.registerValue(exports.Symbols.Cache, new Map());\r\n    }\r\n    _getServiceInfo(key) {\r\n        let serviceInfo = this._services.get(key);\r\n        if (serviceInfo === undefined) {\r\n            const resolverServiceInfo = this._services.get(exports.Symbols.MissingResolver);\r\n            const resolver = resolverServiceInfo.get(this);\r\n            serviceInfo = resolver.get(this, key);\r\n        }\r\n        return serviceInfo;\r\n    }\r\n    _getServiceInfos(key) {\r\n        return this._services.getMany(key);\r\n    }\r\n    get(key) {\r\n        const serviceInfo = this._getServiceInfo(key);\r\n        if (serviceInfo) {\r\n            return this._resolveStack.with(key, () => serviceInfo.get(this));\r\n        }\r\n        return undefined;\r\n    }\r\n    getRequired(key) {\r\n        const value = this.get(key);\r\n        if (value === undefined) {\r\n            throw new Error('unable to resolve the service');\r\n        }\r\n        return value;\r\n    }\r\n    getMany(key) {\r\n        const serviceInfos = this._getServiceInfos(key);\r\n        return this._resolveStack.with(key, () => serviceInfos.map(si => si.get(this)));\r\n        ;\r\n    }\r\n    registerServiceInfo(key, serviceInfo) {\r\n        this._services.set(key, serviceInfo);\r\n    }\r\n    registerValue(key, value) {\r\n        this._services.set(key, new Services.ValueServiceInfo(value));\r\n    }\r\n    register(key, factory, lifetime) {\r\n        this._services.set(key, new Services.ServiceInfo(factory, lifetime, this));\r\n    }\r\n    registerTransient(key, factory) {\r\n        return this.register(key, factory, LifeTime.Transient);\r\n    }\r\n    registerScoped(key, factory) {\r\n        return this.register(key, factory, LifeTime.Scoped);\r\n    }\r\n    registerSingleton(key, factory) {\r\n        return this.register(key, factory, LifeTime.Singleton);\r\n    }\r\n    registerGroup(key, keys) {\r\n        this._services.set(key, new Services.GroupedServiceInfo(keys));\r\n    }\r\n    registerBind(key, target) {\r\n        this._services.set(key, new Services.BindedServiceInfo(target));\r\n    }\r\n    scope() {\r\n        return new ScopedServiceProvider(this._services.child());\r\n    }\r\n}\r\n/**\r\n * the main class for anyioc.\r\n *\r\n * @export\r\n * @class ServiceProvider\r\n * @extends {ScopedServiceProvider}\r\n */\r\nclass ServiceProvider extends ScopedServiceProvider {\r\n    constructor() {\r\n        super(new Utils.ChainMap());\r\n        this.registerServiceInfo(exports.Symbols.Provider, new Services.ProviderServiceInfo());\r\n        this.registerValue(exports.Symbols.RootProvider, this);\r\n        this.registerValue(exports.Symbols.MissingResolver, new Resolvers.EmptyServiceInfoResolver());\r\n        // alias\r\n        this.registerTransient('ioc', ioc => ioc.get(exports.Symbols.Provider));\r\n        this.registerTransient('provider', ioc => ioc.get(exports.Symbols.Provider));\r\n    }\r\n}\r\nexports.ServiceProvider = ServiceProvider;\r\n// gist: a85a89bcdc9445148ce213a3d31eeeb2\r\nfunction getGlobal() {\r\n    if (typeof globalThis !== 'undefined') {\r\n        return globalThis;\r\n    }\r\n    else if (typeof window !== 'undefined') {\r\n        return window; // browser\r\n    }\r\n    else if (typeof global != 'undefined') {\r\n        return global; // node\r\n    }\r\n    else {\r\n        throw Error('unknown');\r\n    }\r\n}\r\nconst iocSymbol = Symbol.for('anyioc://ioc');\r\nexports.ioc = (function () {\r\n    const g = getGlobal();\r\n    if (g[iocSymbol] === undefined) {\r\n        g[iocSymbol] = new ServiceProvider();\r\n    }\r\n    return g[iocSymbol];\r\n})();\r\n//# sourceMappingURL=anyioc.js.map","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n"],"sourceRoot":""}